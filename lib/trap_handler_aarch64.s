//Add aarch64 support by @tingwei628 

// SPIM S20 MIPS simulator.
//
// Modified trap handler for COOL runtime.
//
// 2/01/95 Carleton Miyamoto
// 8/19/94 Manuel Fahndrich
//
// $Log: trap.handler,v $
// Revision 1.9  2004/04/21 02:13:53  bec
// Merged-in changes to print the class of the exception
//
// Revision 1.8  2004/04/20 03:04:02  bec
// Merged-in handler for exceptions.  This will not affect code generators
// that do not implement exceptions.
//
// Revision 1.7  2004/01/22 03:06:34  jcondit
// merged matth's changes (gc init msgs) from sp03
//
// Revision 1.6  2003/07/20 18:52:58  matth
// fixed a bug in the comments of Object.copy: t3 and t4 are clobberred
//
// Revision 1.5  2003/04/12 02:36:54  matth
// updated trap.handler for Spim 6.5.  (Don't use andi with 32-bit immediates)
//
// Revision 1.4  2001/04/23 09:47:32  smcpeak
// fixed an off-by-1 bug in stack tracing code
//
// Revision 1.3  2001/03/23 07:30:53  smcpeak
// fixed _GenGC_Assign so it doesn't clobber $a0
//
// Revision 1.2  1996/10/12 18:54:35  darcy
// AFter Merge versitons.
//
// Revision 1.1.1.1.4.1  1996/09/17 08:21:39  aiken
// new Makefile, new resuls
//
//
//
// - updated instructions
// - cleanup of Makefile + new parameters
// - new VERSION file
//
// cleanup of Makefile; removed -static
//
// fixed a bug in PA2 assignment skeleton
//
// paramaterization
//
// updated skeletons to pass ostreams by ref
// paramaterized makefile
//
//
// pass ostreams by ref in SKEL
// parameterized Makefile
//
// new parameters
//
// new parameters
//
// just copied, not actually updated
//
// Revision 1.1.1.1  1996/07/12 06:48:08  aiken
// Imported sources
//
// Revision 2.3  1996/05/31 17:55:22  aiken
// added copyright notice
//
// Revision 2.2  1996/05/28 22:02:38  aiken
// fixed spelling errors,
// brought comments up to date
//
// Revision 2.1  1995/11/08 01:14:41  dgay
// Add a _MemMgr_Test function that calls the garbage collector if the
// global _MemMgr_TEST is non-zero (this global is generated by coolc
// when the -t option is used).
// _MemMgr_Test is called on every memory allocation, i.e. in Object.copy,
// String.concat, String.substr, IO.in_string, IO.in_int
//
// Revision 2.0  1995/09/26 01:26:13  dgay
// - Merged changes between revisions 1.12 and 1.13 of trap handler into
//   trap handler for GC from miyamoto.
// - Fixed bug in generational GC: didn't handle assignments properly
//   (registers were trashed)
// - Changed method of identifying pointers on stack:
//   no tags pushed, simply checks that values are even and are in the
//   correct address range. Aborts if eyecatcher missing.
// - Added _gc_check primitive to check the presence of an eyecatcher
//   on an object.
// - Removed the Stop & Copy GC.
//
//   Revision 2.2  1995/05/17  20:15:41  miyamoto
//   - The "NoGC" garbage collector.  This collector does nothing but
//     expand the heap when more memory is required.
//   - support for multiple garbage collectors added.
//   - "_MemMgr_*" functions give an consistent view of the garbage
//     collectors.  It uses the addresses stored in "_MemMgr_INITIALIZER"
//     and "_MemMgr_COLLECTOR" to run the correct garbage collector.
//   - "_MemMgr_INITIALIZER" holds the address of the initialization
//     function for the garbage collector.  This is defined in the
//     program file (*.s).
//   - "_MemMgr_COLLECTOR" holds the address of the garbage collection
//     function.  This is defined in the program file (*.s).
//   - MemMgr_REG_MASK is used to determine which registers get auto-
//     updated.
//   - "_*GC_*Alloc" functions were removed.
//   - "*_REG_MASK" variables removed.
//
//   Revision 2.1  1995/03/13  15:58:32  miyamoto
//   - GenGC "Generational" garbage collector
//   - Converted all calls to "_SncGC_*" to their equivalent "_GenGC_*"
//   - Created constants:
//     GenGC_HDR*: Information in the GenGC header
//     GenGC_REG_MASK: Register mask for auto update
//     GenGC_ARU_MASK: All possible registers that can be auto updated
//     GenGC_HEAPEXPGRAN: Granularity of any heap expansion, heap is
//       always expanded in multiples of 2^GenGC_HEAPEXPGRAN
//     GenGC_OLDRATIO: Ratio of size of the old area to usable heap size
//   - Created GenGC error messages in the data seg (_GenGC_*)
//   - Object.copy: displays error message on an invalid object size
//
//   Revision 2.0  1995/02/16  17:32:38  miyamoto
//   - SncGC "Stop and Copy" garbage collector
//   - Created some constants:
//     obj_eyecatch: offset from object pointer to the eyecatcher
//     obj_disp: offset from object pointer to the dispatch table
//     obj_attr: offset from object pointer to the attributes
//     str_maxsize: the maximum length of a string
//     SncGC_REG_MASK: Register mask for auto update
//     SncGC_ARU_MASK: All possible registers that can be auto updated
//     SncGC_EXPANDSIZE: Size to expand heap when necessary (bytes)
//     SncGC_INFOSIZE: Size of SncGC header in the heap (bytes)
//   - Created some SncGC error messages in the data seg (_SncGC_*)
//   - Renamed labels in equality_test to contain a leading underscore
//     to avoid any conflicts which may arise
//   - Functions changed to accomodate SncGC:
//     __start: pushs Main object on the stack and calls "_SncGC_Init"
//     Object.copy: calls "_SncGC_Alloc" to allocate memory
//     IO.in_string, String.concat, String.substr:
//       uses "_SncGC_QAlloc" to verify allocation of memory
//   - Functions changed to accomodate stack flags:
//     Object.copy, IO.out_string, IO.out_int, IO.in_int, IO.in_string
//     String.concat, String.substr
//   - __start now sets $s0 to the self pointer of the Main object
//
//   *****
//   Warning (no changes made): String.substr trashes regs $t3 $t4
//   *****
//
//   Revision 1.12  1994/11/15  03:33:34  manuel
//   substr method didn't allow taking the empty substr at the end of a
//   string
//
//   Revision 1.11  1994/11/14  21:41:23  manuel
//   Comment for equality_test contained a type: arguments are in $t1 and
//   $t2
//
//   Revision 1.10  1994/10/26  02:31:50  manuel
//   Added more comments.
//
//   Revision 1.9  1994/08/31  02:04:31  manuel
//   Fixed an error in the in_string code: Reading from EOF, the system
//   returns 0 characters. We test for this and return a single '\n'. The
//   code can therefore recognize EOF.
//   The last line of a file must be terminated by a newline, otherwise
//   spim gets confused and returns the entire buffer!
//
//   Revision 1.8  1994/08/28  02:21:46  manuel
//   - Fixed typo in system message
//
//   Revision 1.7  1994/08/27  08:53:35  manuel
//   - Added an .align at end of data segment to be safe. Cgen should emit
//     one.
//
//   Revision 1.6  1994/08/27  08:37:49  manuel
//   - Added string primitives
//
//   Revision 1.5  1994/08/27  04:42:25  manuel
//   - Adapted code to handle String Class containing an Int object slot
//     for the string size.
//
//   Revision 1.4  1994/08/27  02:01:43  manuel
//   - Fixed typos
//
//   Revision 1.2  1994/08/27  00:41:01  manuel
//   - Changed string object representation to two slots. The first is a 32
//     bit slot indicating the string length, the second is a variable
//     sized slot containing the actual null terminated string.
//   - Fixed a bug in the in_string function which set obj_size to
//     4*obj_size
//   - Added constants for field offsets
//
//
// SPIM is distributed under the following conditions:
//
// You may make copies of SPIM for your own use and modify those copies.
//
// All copies of SPIM must retain my name and copyright notice.
//
// You may not sell SPIM or distributed SPIM in conjunction with a commerical
// product or service without the expressed written consent of James Larus.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE.
//

	.data
// system call number
.equ SYS_READ, 0x3f
.equ SYS_WRITE, 0x40
.equ SYS_BRK, 0xd6
.equ SYS_EXIT, 0x5d
// Define some constants
.equ obj_eyecatch, -4 // Unique id to verify any object
.equ obj_tag, 0
.equ obj_size, 4
.equ obj_disp, 8
.equ obj_attr, 12
.equ int_slot, 12
.equ bool_slot, 12
.equ str_size, 12	// This is a pointer to an Int object!!!
.equ str_field, 16	// The beginning of the ascii sequence
.equ str_maxsize, 1026	// the maximum string length

.equ array_maxsize_read_int, 12 // char array size for reading int

.equ GenGC_HDRSIZE, 44				// size of GenGC header
.equ GenGC_HDRL0, 0					// pointers to GenGC areas
.equ GenGC_HDRL1, 4
.equ GenGC_HDRL2, 8
.equ GenGC_HDRL3, 12
.equ GenGC_HDRL4, 16
.equ GenGC_HDRMAJOR0, 20				// history of major collections
.equ GenGC_HDRMAJOR1, 24
.equ GenGC_HDRMINOR0, 28				// history of minor collections
.equ GenGC_HDRMINOR1, 32
.equ GenGC_HDRSTK, 36					// start of stack
.equ GenGC_HDRREG, 40					// current REG mask
.equ GenGC_HEAPEXPGRAN, 14				// 2^14=16K
.equ GenGC_OLDRATIO, 2				// 1/(2^2)=.25=25%

.equ MemMgr_REG_MASK, 0x007F0000
.equ NoGC_EXPANDSIZE, 0x10000 // size to expand heap
/*
callee register in AArch64
$s0 -> x19
$s1 -> x20
$s2 -> x21
$s3 -> x22
$s4 -> x23
$s5 -> x24
$s6 -> x25
$s7 -> x26
$gp -> x27

caller register in AArch64
$t1 -> x9
$t2 -> x10
$t3 -> x11
$t0 -> x12 (this is NOT typo)
$t4 -> x13
$t8 -> x14 
$t9 -> x15

arguments register in AArch64
$a0 -> x0
$a1 -> x1
$a2 -> x2

$v0 -> x6
$v1 -> x7

// $16 ~ $22 $24 $25 $30 $31
// $s0 ~ $s6 $t8 $t9 $fp $ra
// x19 ~ x25 x14 x15 x29 x30
*/
//.string directive is an alias for .asciz
_num: .word 0
_fmt_int_array: .space array_maxsize_read_int
_fmt_int_size=.-fmt_int_array
_fmt_read_int: .string "%d"
_fmt_print_int: .asciz "%d" // printf int format
_fmt_str_array: .space str_maxsize
_fmt_str_size=.- _fmt_str_array
_abort_msg:	.asciz "Abort called from class "
_colon_msg:	.asciz ":"
_dispatch_msg:  .asciz ": Dispatch to void.\n"
_cabort_msg:	.asciz "No match in case statement for Class "
_cabort_msg2:   .asciz "Match on void in case statement.\n"
_nl:		.asciz "\n"
_term_msg:	.asciz "COOL program successfully executed\n"
_sabort_msg1:	.asciz	"Index to substr is negative\n"
_sabort_msg2:	.asciz	"Index to substr is too big\n"
_sabort_msg3:	.asciz	"Length to substr too long\n"
_sabort_msg4:	.asciz	"Length to substr is negative\n"
_sabort_msg:	.asciz "Execution aborted.\n"
_objcopy_msg:	.asciz "Object.copy: Invalid object size.\n"
_gc_abort_msg:	.asciz "GC bug!\n"

// Exception Handler Message:
_uncaught_msg1: .asciz "\nUncaught Exception of Class "
_uncaught_msg2: .asciz "\nthrown. COOL program aborted.\n"
// Messages for the GenGC garbage collector
_GenGC_INITERROR:	.asciz "GenGC: Unable to initialize the garbage collector.\n"
_GenGC_COLLECT:		.asciz "Garbage collecting ...\n"
_GenGC_Major:		.asciz "Major ...\n"
_GenGC_Minor:		.asciz "Minor ...\n"
_GenGC_MINORERROR:	.asciz "GenGC: Error during minor garbage collection.\n"
_GenGC_MAJORERROR:	.asciz "GenGC: Error during major garbage collection.\n"
_GenGC_Init_test_msg:   .asciz "GenGC initialized in test mode.\n"
_GenGC_Init_msg:        .asciz "GenGC initialized.\n"

// Stack overflow handler message:
// _stack_overflow_msg: .asciiz " Stack overflow detected, COOL program aborted\n"

// Messages for the NoGC garabge collector
_NoGC_COLLECT:		.asciz "Increasing heap...\n"

	//.align 2
	.balign 8

	.text
	.globl __sig_handler2
__sig_handler2:
    stp x29, x30, [sp, #-32]!
    str x0, [sp, #28]
    mov x0, 31
    bl raise
    ldp x29, x30, [sp], #32
    ret

	.globl __sig_handler
__sig_handler:
	stp x29, x30, [sp, #-32]!
	mov x19, x0 // save the expression object
	str x0, [sp, #28]
	ldr x0, =_uncaught_msg1
    bl  puts
	adr x9, class_nameTab
	ldr	x6, [x19, #obj_tag] // Get object tag
    lsl	x6, x6, #2	// *4
	add	x9, x9, x6
	ldr	x9, [x9, #0]	// Load class name string obj.
	add	x0, x9, #str_field // Adjust to beginning of str
	bl  puts
    ldr x0, =_uncaught_msg2
    bl  puts
	ldp x29, x30, [sp], #32   
    mov x0, #1
    bl  exit // exit(1)

/*
	.globl _stack_overflow_abort
// Stack Overflow Message
_stack_overflow_abort:
	la	$a0 _stack_overflow_msg
	li	$v0 4
	syscall			# print message
	li	$v0 10
	syscall			# Exit
*/

# START
	.globl _start
_start:
    // register signal handler
	//signal(SIGINT,sig_handler2);
	mov x0, #2
    ldr x1, =__sig_handler2
    bl signal
	// signal(SIGILL, sig_handler);
	mov x0, #4
    ldr x1, =__sig_handler
    bl signal
	// signal(SIGABRT, sig_handler);
	mov x0, #6
    ldr x1, =__sig_handler
    bl signal
	// signal(SIGBUS, sig_handler);
	mov x0, #7
    ldr x1, =__sig_handler
    bl signal
	// signal(SIGFPE, sig_handler);
	mov x0, #8
    ldr x1, =__sig_handler
    bl signal
	// signal(SIGSEGV, sig_handler);
	mov x0, #11
    ldr x1, =__sig_handler
    bl signal
	// signal(SIGSYS, sig_handler);
    mov x0, #31
    ldr x1, =__sig_handler
    bl signal
 
	mov x0, #0 // mov x0, xzr
	bl sbrk //sbrk
	mov x2, x0 // sbrk return address save to x2
	mov	x1, #MemMgr_REG_MASK
	mov x0, sp // initialize the garbage collector	
	bl	_MemMgr_Init		// sets $gp and $s7 (limit)
	
	adr x0, Main_protObj // create the Main object
	bl Object.copy // Call copy
	add sp, sp, #-8
	str x0, [sp, #4] // save the Main object on the stack
	mov x19, x0 // set $s0 to point to self
	bl Main_init // initialize the Main object
	bl Main.main // Invoke main method

	.globl __main_return
__main_return: # where we return after the call to Main.main
	add sp, sp, #8 // restore the stack
	ldr x0, =_term_msg // show terminal message
	bl puts
	mov x0, #0
	bl exit // exit(0)


	.globl	equality_test
equality_test:			// ops in $t1 $t2
				// true in A0, false in A1
				// assume $t1, $t2 are not equal
	cmp x9, xzr
	b.eq _eq_false // $t2 can't also be void 
	cmp x10, xzr
	b.eq _eq_false // $t1 can't also be void
	ldr x6, [x9, #obj_tag] // get tags
	ldr x7, [x10, #obj_tag]
	cmp x7, x6
	b.ne _eq_false // compare tags
	ldr x2, =_int_tag // load int tag
	ldr x2, [x2]
	cmp x7, x2
	b.eq _eq_int // Integers
	ldr x2, =_bool_tag
	ldr x2, [x2]
	cmp x7, x2
	b.eq _eq_int // Booleans
	ldr x2, =_string_tag // load string tag
	ldr x2, [x2]
	cmp x7, x2
	b.ne _eq_false // Not a primitive type
_eq_str: // handle strings
	ldr x6, [x9, #str_size] // get string size objs
	ldr x7, [x10, #str_size]
	ldr x6, [x6, #int_slot] // get string sizes
	ldr x7, [x7, #int_slot]
	cmp x7, x6
	b.ne _eq_false
	cmp x7, xzr
	b.eq _eq_true // 0 length strings are equal
	add x9, x9, #str_field // Point to start of string
	add x10, x10, #str_field
	mov x12, x6 // Keep string length as counter
_eq_l1:
	ldrb w6, [x9, #0] // get char
	add x9, x9, #1
	ldrb w7, [x10, #0] // get char
	add x10, x10, #1
	cmp w7, w6
	b.ne _eq_false
	add x12, x12, #-1 // Decrement counter
	cmp x12, xzr
	b.ne _eq_l1
	b _eq_true // end of strings
		
_eq_int:	// handles booleans and ints
	ldr x6, [x9, #int_slot] // load values
	ldr x7, [x10, #int_slot]
	cmp x7, x6
	b.ne _eq_false
_eq_true:
	ret // return true
_eq_false:
	mov x0, x1 // move false into accumulator
	ret

	.globl	_dispatch_abort
_dispatch_abort:		 
    str x9, [sp, #0] // save line number
	add sp, sp, #-8
	add x0, x0, #str_field // adjust to beginning of string
	bl puts // print file name
	ldr x0, =_colon_msg
	bl puts // print ":"
	ldr x0, =_fmt_print_int
	ldr x1, [sp, #4]
	bl printf // print line number
	ldr x0, =_dispatch_msg
	bl puts // print dispatch-to-void message
	mov x0, #1
	bl exit // exit(1)

	.globl	_case_abort2
_case_abort2:		 
    str x9, [sp, #0] // save line number
	add sp, sp, #-8
	add x0, x0, #str_field // adjust to beginning of string
	bl puts // print file name
	ldr x0, =_colon_msg
	bl puts // print ":"
	ldr x0, =_fmt_print_int
	ldr x1, [sp, #4]
	bl printf // print line number
	ldr x0, =_cabort_msg2
	bl puts // print case-on-void message
	mov x0, #1
	bl exit // exit(1)

	.globl	_case_abort
_case_abort:			// $a0 contains case expression obj.
	mov	x19, x0		// save the expression object
	ldr x0, =_cabort_msg
	bl puts // print_str
	adr x9, class_nameTab
	ldr x6, [x19, #obj_tag] // Get object tag
	lsl x6, x6, #2 // *4
	add x9, x9, x6
	ldr x9, [x9, #0] // Load class name string obj.
	add x0, x9, #str_field // Adjust to beginning of str
	bl puts // print_str
	mov x0, #1
	bl exit // exit(1)

	.globl	Object.copy
Object.copy:
	add sp, sp, #-8 //create stack frame
	str x30, [sp, #8]
	str x0, [sp, #4]
	
	bl _MemMgr_Test // test GC area
	ldr x0, [sp, #4] // get object size
	ldr x0, [x0, #obj_size]
	cmp x0, xzr
	b.le _objcopy_error // check for invalid size
	lsl x0, x0, #2 // convert words to bytes
	add x0, x0, #4 // account for eyecatcher
	bl _MemMgr_Alloc // allocate storage
	add x1, x0, #4 // pointer to new object
	ldr x0, [sp, #4] // the self object
	ldr x30, [sp, #8] // restore return address
	add sp, sp, #8 // remove frame
	ldr x12, [x0, #obj_size] // get size of object
	lsl x12, x12, #2 // convert words to bytes
	b _objcopy_allocated // get on with the copy

// A faster version of Object.copy, for internal use (does not call
// _MemMgr_Test, and if possible not _MemMgr_Alloc)

_quick_copy:
	ldr x12, [x0, #obj_size] // get size of object to copy
	cmp x12, xzr
	b.le _objcopy_error // check for invalid size
	lsl x12, x12, #2 // convert words to bytes
	add x9, x12, #4 // account for eyecatcher
	add x27, x27, x9 // allocate memory
	sub x1, x27, x12 // pointer to new object
	cmp x27, x26
	b.lt _objcopy_allocated // check allocation
_objcopy_allocate:
	sub x27, x1, #4 // restore the original $gp
	add sp, sp, #-8 // frame size
	str x30, [sp, #8] // save return address
	str x0, [sp, #4] // save self
	mov x0, x9 // put bytes to allocate in $a0
	bl _MemMgr_Alloc // allocate storage
	add x1, x0, #4 // pointer to new object
	ldr x0, [sp, #4] // the self object
	ldr x30, [sp, #8] // restore return address
	add sp, sp, #8 // remove frame
	ldr x12, [x0, #obj_size] // get size of object
	lsl x12, x12, #2 // convert words to bytes
_objcopy_allocated:
	add x9, xzr, #-1
	str x9, [x1, #obj_eyecatch] // store eyecatcher
	add x12, x12, x0 // find limit of copy
	mov x9, x1 // save source
_objcopy_loop:
 	ldr x6, [x0, #0]
	str x6, [x9, #0] // copy word
	add x0, x0, #4 // update source
	add x9, x9, #4 // update destination
	cmp x0, x12
	b.ne _objcopy_loop // loop
_objcopy_end:
 	mov x0, x1 // put new object in $a0
	ret // return
_objcopy_error:
	ldr x0, =_objcopy_msg // show error message
	bl puts
	mov x0, #1
	bl exit // exit(1)

	.globl	Object.abort
Object.abort:
	mov x19, x0 // save self
	ldr x0, =_abort_msg
	bl puts // print_str
	adr x9, class_nameTab
	ldr x6, [x19, #obj_tag] // Get object tag
	lsl x6, x6, #2 // *4
	add x9, x9, x6
	ldr x9, [x9, #0] // Load class name string obj.
	add x0, x9, #str_field // Adjust to beginning of str
	bl puts // print_str
	mov x0, #1
	bl exit // exit(1)

	.globl	Object.type_name
Object.type_name:
	adr x9, class_nameTab
	ldr x6, [x0, #obj_tag] // Get object tag
	lsl x6, x6, #2 // *4
	add x9, x9, x6 // index table
	ldr x0, [x9, #0] // Load class name string obj.
	ret

	.globl	IO.out_string
IO.out_string:
	add sp, sp, #8
	str x0, [sp, #4]
	ldr x0, [sp, #8] // get arg
	add x0, x0, #str_field
	bl printf // print_str
	ldr x0, [sp, #4] // return self
	add sp, sp, #8 // pop argument
	ret

	.globl	IO.out_int
IO.out_int:
	add sp, sp, #-8
	str x0, [sp, #4] // save self
	ldr x0, [sp, #8] // get arg
	ldr x0, [x0, #int_slot] // Fetch int
	mov x1, x0
	ldr x0, =_fmt_print_int
	bl printf // print_int
	ldr x0, [sp, #4] // return self
	add sp, sp, #8 // pop argument
	ret

	.globl	IO.in_int
IO.in_int:
	add sp, sp, #-8
	str x30, [sp, #4] // save return address
	adr x0, Int_protObj
	bl _quick_copy // Call copy
	bl Int_init
	add sp, sp, #-8
	str x0, [sp, #4] // save new object

    // reset array and num to read int
    // use memset(arr, 0 ,sizeof(arr)) to clear array
	ldr x0, =_fmt_int_array
    ldr x1, #0
    mov x2, #array_maxsize_read_int
    bl memset
	// reset num to 0
	ldr x1, =_num
	str xzr, [x1]
	// fgets + sscanf to read int 
    ldr x0, =_fmt_int_array
    mov x1, #_fmt_int_size
    ldr x2, =stdin
    ldr x2, [x2]
    bl fgets   
    ldr x1, =_fmt_read_int
    ldr x2, =_num
	bl sscanf
	ldr x6, =_num
	ldr x6, [x6] // return int from $v0
	ldr x0, [sp, #4]
	add sp, sp, #8
	str x6, [x0, #int_slot] // store int read into obj
	ldr x30, [sp, #4]
	add sp, sp, #8
	ret

	.globl	IO.in_string
IO.in_string:
	add sp, sp, #-8
	str x30, [sp, #8] // save return address
	str xzr, [sp, #4] // init GC area
	bl _MemMgr_Test // test GC area
	adr x0, Int_protObj // Int object for string size
	bl _quick_copy
	bl Int_init
	str x0, [sp, #4] // save it
	mov x0, #str_field // size of string obj. header
	add x0, x0, #str_maxsize // max size of string data
	bl _MemMgr_QAlloc // make sure enough room
	adr x0, String_protObj // make string object
	bl _quick_copy
	bl String_init
	ldr x12, [sp, #4] // get size object
	str x12, [x0, #str_size] // store size object in string
	str x0, [sp, #4] // save string object
	add x27, x27, #-4 // overwrite last word
_instr_ok:
   
    // reset array to read string
    // use memset(arr, 0 ,sizeof(arr)) to clear array
	//ldr x0, =_fmt_str_array
    //ldr x1, #0
    //mov x2, #str_maxsize
    //bl memset

 	ldr x0, =_fmt_str_array
    mov x1, #_fmt_str_size
    ldr x2, =stdin
    ldr x2, [x2]
    bl fgets // read string
    bl strlen
	ldr x1, =_fmt_str_array
	sub x0, x0, #1 // x0 (strlen return) has len+1, so it needs to reduced by 1
	str xzr, [x1, x0] // // add '\0' (xzr) to end of string
	mov x27, x1 // move string address to $gp
	mov x12, x27 // t0 to beginning of string
_instr_find_end:
	ldrsb w6, [x27, #0]
 	add x27, x27, #1
	cmp w6, wzr
	b.ne _instr_find_end
	// $gp points just after the null byte
	ldrsb w6, [x12, #0] // is first byte '\0'?
	cmp w6, xzr
	b.ne _instr_noteof
 	//we read nothing. Return '\n' (we don't have '\0'!!!)
 	add x6, xzr, #10 // load '\n' into $v0
	strb w6, [x27, #-1]
	strb wzr, [x27, #0] // terminate
	add x27, x27, #1
	b _instr_nonl
_instr_noteof:
 	// Check if there really is a '\n'
 	ldrsb w6, [x27, #-2]
	cmp w6, #10
	b.ne _instr_nonl
 	// Write '\0' over '\n'
	strb wzr, [x27, #-2] // Set end of string where '\n' was
	add x27, x27, #-1 // adjust for '\n'
_instr_nonl:
 	ldr x0, [sp, #4] // get pointer to new str obj
	ldr x9, [x0, #str_size] // get pointer to int obj
	sub x0, x27, x0
	sub x12, x12, #str_field // calc actual str size
	add x12, x12, #-1 // adjust for '\0'
	str x12, [x9, #int_slot] // store string size in int obj
	add x27, x27, #3 // was already 1 past '\0'
	ldr x12, =0xfffffffc
	and x27, x27, x12 // word align $gp
	sub x12, x27, x0 // calc length
	lsr x12, x12, #2 // divide by 4
	str x12, [x0, #obj_size] // set size field of obj
	ldr x30, [sp, #8] // restore return address
	add sp, sp, #8
	ret // return

	.globl	String.length
String.length:
	ldr x0, [x0, #str_size] // fetch attr
	ret // return

	.globl	String.concat
String.concat:
	add sp, sp, #-32
	str x30, [sp, #16] // save return address
	str x0, [sp, #12] // save self arg.
	str xzr, [sp, #8] // init GC area
	str xzr, [sp, #4] // init GC area
	bl _MemMgr_Test // test GC area
	ldr x0, [sp, #12]
	ldr x0, [x0, #str_size]
	bl _quick_copy // Call copy
	str x0, [sp, #8] // save new size object
	ldr x9, [sp, #20] // load arg object
	ldr x9, [x9, #str_size] // get size object
	ldr x9, [x9, #int_slot] // arg string size
	cmp x9, xzr
	b.le _strcat_argempty // nothing to add
	ldr x12, [sp, #12] // load self object
	ldr x12, [x12, #str_size] // get size object
	ldr x12, [x12, #int_slot] // self string size
	add x12, x12, x9 // new size
	str x12, [x0, #int_slot] // store new size
	add x0, x12, #str_field // size to allocate
	add x0, x0, #4 // include '\0', +3 to align
	ldr x10, =0xfffffffc // 0xfffffffc (= 1111 1111 1111 1111 1111 1111 1111 1100)
	and x0, x0, x10 // align on word boundary (& 0xfffffffc which can be divided by 4)
	add x0, x0, #1 // make size odd for GC <-|
	str x0, [sp, #4] // save size in bytes     |
	add x0, x0, #3 //  save size in bytes     |
	bl _MemMgr_QAlloc // check memory
	ldr x0, [sp, #12] // copy self
	bl _quick_copy // Call copy
	ldr x12, [sp, #8] // get the Int object
	str x12, [x0, #str_size] // store it in the str obj.
	sub x9, x27, x0 // bytes allocated by _quick_copy
	ldr x12, [sp, #4] // get size in bytes (no eyecatcher)
	sub x12, x12, #1 // Remove extra 1 (was for GC)
	sub x9, x12, x9 // more memory needed
	add x27, x27, x9 // allocate rest
	lsr x12, x12, #2 // convert to words
	str x12, [x0, #obj_size] // save new object size
	ldr x12, [sp, #12] // get original self object
	ldr x12, [x12, #str_size] // get size object
	ldr x12, [x12, #int_slot] // self string size
	add x9, x0, #str_field // points to start of string data
	add x9, x9, x12 // points to end: '\0'
	ldr x12, [sp, #20] // load arg object
	add x10, x12, #str_field // points to start of arg data
	ldr x12, [x12, #str_size] // get arg size
	ldr x12, [x12, #int_slot]
	add x12, x12, x10 // find limit of copy
_strcat_copy:
	ldrsb w6, [x10, #0] // load from source
	strb w6, [x9, #0] // save in destination
	add x10, x10, #1 // advance each index
	add x9, x9, #1
	cmp x10, x12
	b.ne _strcat_copy
	strb wzr [x9, #0] // add '\0'
	ldr x30, [sp, #16] // restore return address
	add sp, sp, #40 // pop argument
	ret // return
_strcat_argempty:
	ldr x0, [sp, #12] // load original self
	ldr x30, [sp, #16] // restore return address
	add sp, sp, #40 // pop argument
	ret // return

	.globl	String.substr
String.substr:
	add sp, sp, #-24 // frame
	str x30, [sp, #4] // save return
	str x0, [sp, #12] // save self
	str xzr, [sp, #8] // init GC area
	bl _MemMgr_Test // test GC area
	ldr x0, [sp, #12]
	ldr x6, [x0, #obj_size]
	adr x0, Int_protObj // ask if enough room to allocate
	ldr x0, [x0, #obj_size] // a string object, an int object,
	add x0, x0, x6 // and the string data
	add x0, x0, #2 // include 2 eyecatchers
	lsl x0, x0, #2
	add x0, x0, #str_maxsize
	bl _MemMgr_QAlloc
_ss_ok:
	adr x0, Int_protObj
	bl _quick_copy
	bl Int_init
	str x0, [sp, #8] // save new length obj
	adr x0, String_protObj
	bl _quick_copy
	bl String_init // new obj ptr in $a0
	mov x2, x0 // use a2 to make copy
	add x27, x27, #-4 // backup alloc ptr
	ldr x1, [sp, #12] // load orig
	ldr x9, [sp, #20] // index obj
	ldr x10, [sp, #16] // length obj
	ldr x12, [x1, #str_size]
	ldr x7, [x9, #int_slot] // index
	ldr x6, [x12, #int_slot] // size of orig
	cmp x7, xzr
	b.lt _ss_abort1 // index is smaller than 0
	cmp x7, x6
	b.gt _ss_abort2 // index > orig
	ldr x11, [x10, #int_slot] // sub length
	add x7, x7, x11 // index+sublength
	cmp x7, x6
	b.gt _ss_abort3
	cmp x11, xzr
	b.lt _ss_abort4
	ldr x13, [sp, #8] // load new length obj
	str x11, [x13, #int_slot] // save new size
	str x13, [x0, #str_size] // store size in string
	ldr x7, [x9, #int_slot] // index
	add x1, x1, #str_field // advance src to str
	add x1, x1, x7 // advance to indexed char
	add x2, x2, #str_field // advance dst to str
	cmp x11, xzr
	b.eq _ss_end // empty length
_ss_loop:
	ldrsb w6, [x1, #0]
	add x1, x1, #1 // inc src
	strb w6, [x2, #0]
	add x2, x2, #1 // inc dst
	add x11, x11, #-1 // dec ctr
	cmp x11, xzr
	b.ne _ss_loop
_ss_end:
	strb wzr [x2, #0] // null terminate (sb rt address ;store byte in rt to address)
	mov x27, x2
	add x27, x27, #4 // realign the heap ptr
	ldr x12, =0xfffffffc
	and x27, x27, x12 // word align $gp
	sub x12, x27, x0 // calc object size
	lsr x12, x12, #2 // div by 4 (srl - shift right logical)
	str x12, [x0, #obj_size]	
	ldr x30, [sp, #4]
	add sp, sp, #40 // pop arguments
	ret
_ss_abort1:
	ldr	x0, =_sabort_msg1
	b _ss_abort
_ss_abort2:
	ldr	x0, =_sabort_msg2
	b _ss_abort
_ss_abort3:
	ldr	x0, =_sabort_msg3
	b _ss_abort
_ss_abort4:
	ldr	x0, =_sabort_msg4
_ss_abort:
	bl puts
	ldr x0, =_sabort_msg
	bl puts
	mov x0, #1
	bl exit // exit(1)

	.globl _MemMgr_Init
_MemMgr_Init:
	str x30, [sp, #-8]! // save return address
	adr x12, _MemMgr_INITIALIZER // pointer to initialization
	ldr x12,  [x12, #0]
	blr x12 // initialize
	ldr x30, [sp], #8 // restore return address
	ret // return

	.globl _MemMgr_Alloc
_MemMgr_Alloc:
    add x27, x27, x0 // attempt to allocate storage
	cmp x27, x26
	b.lt _MemMgr_Alloc_end // check allocation
	sub x27, x27, x0 // restore $gp
	add sp, sp, #-8
	str x30, [sp, #4] // save return address
	mov x1, x0 // size
	add x0, sp, #4 // end of stack to collect
	adr x12, _MemMgr_COLLECTOR // pointer to collector function
	ldr x12, [x12 #0]
	blr x12 // garbage collect
    ldr x30, [sp, #4]
	add sp, sp, #8
	mov x0, x1 // put size into $a0
	add x27, x27, x0 // allocate storage
_MemMgr_Alloc_end:
	sub x0, x27, x0
	ret // return

	.globl _MemMgr_QAlloc
_MemMgr_QAlloc:
	add x12, x27, x0
	cmp x12, x26
	b.lt _MemMgr_QAlloc_end // check allocation
	add sp, sp, #-8 // attempt to allocate storage
	str x30, [sp, #4] // save return address
	mov x1, x0 // size
	add x0, sp, #4 // end of stack to collect
	adr x12, _MemMgr_COLLECTOR // pointer to collector function
	ldr x12, [x12, #0]
	blr x12 // garbage collect
	ldr x30, [sp, #4] // restore return address
	add sp, sp, #8
	mov x0, x1 // put size into $a0
_MemMgr_QAlloc_end:
	ret // return

	.globl	_MemMgr_Test
_MemMgr_Test:
	adr x12, _MemMgr_TEST // Check if testing enabled
	ldr x12, [x12, #0]
	cmp x12, xzr
	b.eq _MemMgr_Test_end

# Allocate 0 bytes
	add sp, sp, #-8 // Save return address
	str x30, [sp, #4]
	mov x1, #0 // size = 0
	add x0, sp, #4 // end of stack to collect
	adr x12, _MemMgr_COLLECTOR // pointer to collector function
	ldr x12, [x12, #0]
	blr x12 // garbage collect
	ldr x30, [sp, #4] // restore return address
	add sp, sp, #8

_MemMgr_Test_end:
	ret

//
// GenGC Generational Garbage Collector
//
//   This is an implementation of a generational garbage collector
//   as described in "Simple Generational Garbage Collection and Fast
//   Allocation" by Andrew W. Appel [Princeton University, March 1988].

	.globl _GenGC_Init
_GenGC_Init:
	adr x12, heap_start
	add x9, x12, #GenGC_HDRSIZE
	str x9, [x12, #GenGC_HDRL0] // save start of old area
	str x9, [x12, #GenGC_HDRL1] // save start of reserve area
	sub x9, x2, x9 // find reserve/work area barrier
	lsr x9, x9, #1
	ldr x6, =0xfffffffc
	and x9, x9, x6
	cmp t1, xzr            // heap initially to small
	b.le _GenGC_Init_error //
	sub	x27, x2, x9
	str x27, [x12, #GenGC_HDRL2] // save start of work area
	str x2, [x12, #GenGC_HDRL3] // save end of work area
	mov x26, x2 // set limit pointer
	str xzr, [x12, #GenGC_HDRMAJOR0] // clear histories
	str xzr, [x12, #GenGC_HDRMAJOR1]
	str xzr, [x12, #GenGC_HDRMINOR0]
	str xzr, [x12, #GenGC_HDRMINOR1]
	str x0, [x12, #GenGC_HDRSTK] // save stack start
	str x1, [x12, #GenGC_HDRREG] // save register mask
	mov x0, #0 // get heap end
    bl sbrk
	mov x6, x0
	str x6, [x12, #GenGC_HDRL4] // save heap limit
    adr x12, _MemMgr_TEST // Check if testing enabled
	ldr x12, [x12, #0]
	cmp x12, xzr
	b.eq _MemMgr_Test_false
	ldr x0, =_GenGC_Init_test_msg // tell user GC is in test mode
	bl puts
	b _GenGC_Init_end
_MemMgr_Test_false:
	ldr x0, =_GenGC_Init_msg
	bl puts
_GenGC_Init_end:
	ret // return
_GenGC_Init_error:
	ldr x0, =_GenGC_INITERROR //show error message
	bl puts
	mov x0, #1 // exit
	bl exit

	.globl _GenGC_Assign
_GenGC_Assign:
	add x26, x26, #-4
	str x1, [x26, #0] // save pointer to assignment
	cmp x26, x27
	b.gt _GenGC_Assign_done
	add sp, sp, #-8
	str x30, [sp, #8] // save return address
	str x0, [sp, #4] // sm: save $a0
	mov x1, xzr // size
	add x0, sp, #0 // end of stack to collect
	str xzr [sp, #0] // play it safe with off-by-1
	bl _GenGC_Collect
	ldr x30, [sp, #8] // restore return address
	ldr x0, [sp, #4] // restore $a0
	add sp, sp, #8
_GenGC_Assign_done:
	ret // return

	.globl	_gc_check
_gc_check:
	cmp x1, xzr
	b.eq _gc_ok // void is ok
	ldr x2, [x1, #obj_eyecatch]
	add x2, x2, #1
	cmp x2, xzr
	b.ne _gc_abort
_gc_ok:
	ret // return

_gc_abort:		 
	ldr x0, =_gc_abort_msg
	bl puts
	mov x0, #1
	bl exit // exit(1)

	.globl _GenGC_Collect
_GenGC_Collect:
	add sp, sp, #24
	str x30, [sp, #12] // save return address
	str x0, [sp, #8] // save stack end
	str x1, [sp, #4] // save size
	ldr x0, =_GenGC_COLLECT // print collection message
	bl puts
	ldr x0, [sp, #8] // restore stack end
	bl _GenGC_MinorC // minor collection
	adr x1, heap_start
	ldr x9, [x1, #GenGC_HDRMINOR1]
	add x9, x9, x0
	lsr x9, x9, #1
	str x9, [x1, #GenGC_HDRMINOR1] // update histories
    str x0, [x1, #GenGC_HDRMINOR0]
	mov x12, x9 // set $t0 to max of minor
	cmp x9, x0
	b.gt _GenGC_Collect_maxmaj
	mov x12, x0
_GenGC_Collect_maxmaj:
	ldr x9, [x1, #GenGC_HDRMAJOR0] // set $t1 to max of major
	ldr x10, [x1, #GenGC_HDRMAJOR1]
	cmp x9, x10
	b.gt _GenGC_Collect_maxdef
	mov x9, x10
_GenGC_Collect_maxdef:
	ldr x10, [x1, #GenGC_HDRL3]
	sub x12, x10, x12 // set $t0 to L3-$t0-$t1
	sub x12, x12, x9
	ldr x9, [x1, #GenGC_HDRL0] // set $t1 to L3-(L3-L0)/2
	sub x9, x10, x9
	lsr x9, x9, #1
	sub x9, x10, x9
	cmp x12, x9
	b.lt _GenGC_Collect_breakpt // set $t0 to minimum of above
	mov x12, x9
_GenGC_Collect_breakpt:
	ldr x9, [x1, #GenGC_HDRL1] // get end of old area
	cmp x9, x12
	b.ge _GenGC_Collect_major
	ldr x12, [x1, #GenGC_HDRL2]
	ldr x9, [x1, #GenGC_HDRL3]
	ldr x10, [sp, #4] // load requested size into $t2
	sub x12, x9, x12 // find reserve/work area barrier
	lsr x12, x12, #1
	ldr x11, =0xfffffffc
	and x12, x12, x11
	sub x12, x9, x12 // reserve/work barrier
	add x10, x12, x10 // test allocation
	cmp x10, x9
	b.ge _GenGC_Collect_major // check if work area too small
_GenGC_Collect_nomajor:
 	ldr x9, [x1, #GenGC_HDRL2]
	str x9, [x1, #GenGC_HDRL1] // expand old area
	str x12, [x1, #GenGC_HDRL2] // set new reserve/work barrier
	mov x27, x12 // set $gp
	ldr x26, [x1, #GenGC_HDRL3] // load limit into $s7
	b _GenGC_Collect_done
_GenGC_Collect_major:
	ldr x0, =_GenGC_Major // print collection message
	bl puts
	ldr x0, [sp, #8] // restore stack end
	bl _GenGC_MajorC // major collection
	adr x1, heap_start
	ldr x9, [x1, #GenGC_HDRMAJOR1]
	add x9, x9, x0
	lsr x9, x9, #1
	str x9, [x1, #GenGC_HDRMAJOR1] // update histories
	str x0, [x1, #GenGC_HDRMAJOR0]
	ldr x9, [x1, #GenGC_HDRL3] // find ratio of the old area
	ldr x12, [x1, #GenGC_HDRL0]
	sub x9, x9, x12
	lsr x9, x9, #GenGC_OLDRATIO
	add x9, x12, x9
	ldr x12, [x1, #GenGC_HDRL1]
	sub x12, x12, x9
	lsl x12, x12, #GenGC_OLDRATIO // amount to expand in $t0
	ldr x9, [x1, #GenGC_HDRL3] // load L3
	ldr x10, [x1, #GenGC_HDRL1] // load L1
	sub x10, x9, x10
	lsr x10, x10, #1
	ldr x11, =0xfffffffc
	and x10, x10, x11
	sub x9, x9, x10 // reserve/work barrier
	ldr x10, [sp, #4] // restore size
	add x9, x9, x10
	ldr x10, [x1, #GenGC_HDRL3] // load L3
	sub x9, x9, x10 // test allocation
	add x9, x9, #4 // adjust for round off errors
	lsl x9, x9, #1 // need to allocate $t1 memory
	cmp x9, x12
	b.lt _GenGC_Collect_enough // put max of $t0, $t1 in $t0
	mov x12, x9
_GenGC_Collect_enough:
	cmp x12, xzr
	b.le _GenGC_Collect_setL2 // no need to expand
	add x9, xzr, #1 // put 1 in $t1
	lsl x9, x9, #GenGC_HEAPEXPGRAN // get granularity of expansion
	add x9, x9, #-1 // align to granularity
	add x12, x12, x9
	mvn x9, x9
	and x12, x12, x9 // total memory needed
	ldr x9, [x1, #GenGC_HDRL3] // load L3
	ldr x9, [x1, #GenGC_HDRL4] // load L4
	sub x9, x10, x9
	sub x10, x12, x9 // actual amount to allocate
	cmp x10, xzr
	b.gt _GenGC_Collect_getmem // check if really need to allocate
_GenGC_Collect_xfermem:
	ldr x26, [x1, #GenGC_HDRL3] // load L3
	add x26, x26, x12 // expand by $t0, set $s7
	str x26, [x1, #GenGC_HDRL3] // save L3
	b _GenGC_Collect_findL2
_GenGC_Collect_getmem:
	mov x0, x10 // set the size to expand the heap
	bl sbrk
	mov x0, #0 // get new end of heap in $v0
	bl sbrk
	str x0, [x1, #GenGC_HDRL4] // save L4
	str x0, [x1, #GenGC_HDRL3] // save L3
	mov x26, x0 // set $s7
	b _GenGC_Collect_findL2
_GenGC_Collect_setL2:
	ldr x26, [x1, #GenGC_HDRL3] // load L3
_GenGC_Collect_findL2:
	ldr x9, [x1, #GenGC_HDRL1] // load L1
	sub x9, x26, x9
	lsr x9, x9, #1
	ldr x12, =0xfffffffc
	and x9, x9, x12
	sub x27, x26, x9 // reserve/work barrier
	str x27, [x1, #GenGC_HDRL2] // save L2
_GenGC_Collect_done:
// Clear new generation to catch missing pointers
	mov x12, x27
_GenGC_Clear_loop:
	str xzr, [x12, #0]
 	add x12, x12, #4
	cmp x12, x26
	b.lt _GenGC_Clear_loop
	
	str x1, [sp, #4] // restore size
	str x30, [sp, #12] // restore return address
 	add sp, sp, #24
	ret // return

	.globl _GenGC_ChkCopy
_GenGC_ChkCopy:
 	cmp x0, x1
	b.lt _GenGC_ChkCopy_done // check bounds
	cmp x0, x2
	b.ge _GenGC_ChkCopy_done
	and x10, x0, #1 // check if odd
	cmp x10, xzr
	b.ne _GenGC_ChkCopy_done
	add x10, xzr, #-1
	ldr x9, [x0, #obj_eyecatch] // check eyecatcher
	cmp x10, x9
	b.ne _gc_abort
	ldr x9, [x0, #obj_tag] // check object tag
	cmp x10, x9
	b.eq _GenGC_ChkCopy_done
	ldr x9, [x0, #obj_size] // get size of object
	cmp  x9, xzr
	b.eq _GenGC_ChkCopy_forward // if size = 0, get forwarding pointer
	mov x12, x0 // save pointer to old object in $t0
	add x27, x27, #4 // allocate memory for eyecatcher
	mov x0, x27 // get address of new object
	str x10, [x0, #obj_eyecatch] // save eye catcher
	lsl x9, x9, #2 // convert words to bytes
	add x9, x12, x9 // set $t1 to limit of copy
	mov x10, x12 // set $t2 to old object
_GenGC_ChkCopy_loop:
	ldr x6, [x12, #0] // copy
	str x6, [x27, #0]
	add x12, x12, #4 // update each index
	add x27, x27, #4
 	cmp x12, x9
	b.ne _GenGC_ChkCopy_loop // check for limit of copy
 	str xzr, [x10, #obj_size] // set size to 0
	str x0, [x10, #obj_disp] // save forwarding pointer
_GenGC_ChkCopy_done:
	ret // return
_GenGC_ChkCopy_forward:
	ldr x0, [x0, #obj_disp] // get forwarding pointer
 	ret // return

 	.globl _GenGC_MinorC
_GenGC_MinorC:
	add sp, sp, #-40
 	str x30, [sp, #20] // save return address
	adr x12, heap_start
	ldr x1, [x12, #GenGC_HDRL2] // set lower bound to work area
	mov x2, x26 // set upper bound for ChkCopy
	ldr x27, [x12, #GenGC_HDRL1] // set $gp into reserve area
	str x0, [sp, #16] // save stack end
	ldr x12, [x12, #GenGC_HDRSTK] // set $t0 to stack start
	mov x9, x0 // set $t1 to stack end
	cmp x12, x9
	b.le _GenGC_MinorC_stackend // check for empty stack
_GenGC_MinorC_stackloop: // $t1 stack end, $t0 index
 	add x12, x12, #-4 // update index
	str x12, [sp, #12] // save stack index
	ldr x0, [x12, #4] // get stack item
	bl _GenGC_ChkCopy // check and copy
	ldr x12, [sp, #12] // load stack index
	str x0, [x12, #4]
	ldr x9, [sp, #16] // restore stack end
	cmp x12, x9 // loop
	b.gt _GenGC_MinorC_stackloop
_GenGC_MinorC_stackend:
 	adr x12, heap_start
	ldr x12, [x12, #GenGC_HDRREG] // get Register mask
	str x12, [sp, #16] // save Register mask
_GenGC_MinorC_reg16:
 	lsr x12, x12, #16 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg17 // check if set
	mov x0, x19 // set test pointer
	bl _GenGC_ChkCopy
	mov x19, x0 // update register
_GenGC_MinorC_reg17:
	ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #17 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg18 // check if set
	mov x0, x20 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x20, x0 // update register
_GenGC_MinorC_reg18:
 	ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #18 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg19 // check if set
	mov x0, x21 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x21, x0 // update register
_GenGC_MinorC_reg19:
 	ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #19 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg20 // check if set
	mov x0, x22 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x22, x0 // update register
_GenGC_MinorC_reg20:
 	ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #20 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg21 // check if set
	mov x0, x23 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x23, x0 // update register
_GenGC_MinorC_reg21:
 	ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #21 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg22 // check if set
	mov x0, x24 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x24, x0 // update register
_GenGC_MinorC_reg22:
 	ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #22 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg24 // check if set
	mov x0, x25 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x25, x0 // update register
_GenGC_MinorC_reg24:
    ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #24 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg25 // check if set
	mov x0, x14 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x14, x0 // update register
_GenGC_MinorC_reg25:
    ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #25 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg30 // check if set
	mov x0, x15 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x15, x0 // update register
_GenGC_MinorC_reg30:
 	ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #30 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_reg31 // check if set
	mov x0, x29 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x29, x0 // update register
_GenGC_MinorC_reg31:
 	ldr x12, [sp, #16] // restore mask
 	lsr x12, x12, #31 // shift to proper bit
	add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MinorC_regend // check if set
	mov x0, x30 // set test pointer
	bl _GenGC_ChkCopy // check and copy
	mov x30, x0 // update register
_GenGC_MinorC_regend:
	adr x12, heap_start
	ldr x11, [x12, #GenGC_HDRL0] // lower limit of old area
 	ldr x13, [x12, #GenGC_HDRL1] // upper limit of old area
	ldr x12, [x12, #GenGC_HDRL3] // get L3
	str x12, [sp, #16] // save index limit
	cmp x26, x12
	b.ge _GenGC_MinorC_assnend // check for no assignments
_GenGC_MinorC_assnloop:				# $s7 index, $t0 limit
 	ldr x0, [x26, #0] // get table entry
	cmp x0, x11
	b.lt _GenGC_MinorC_assnnext // must point into old area
	cmp x0, x13
	b.ge _GenGC_MinorC_assnnext
	ldr x0, [x0, #0] // get pointer to check
	bl _GenGC_ChkCopy // check and copy
	ldr x12, [x26, #0]
	str x0, [x12, #0] // update pointer
	ldr x12, [sp, #16] // restore index limit
_GenGC_MinorC_assnnext:
 	add x26, x26, #4 // update index
	cmp x26, x12
	b.lt _GenGC_MinorC_assnloop // loop
_GenGC_MinorC_assnend:
 	adr x12, heap_start
	ldr x12, [x12, #GenGC_HDRL1] // start of reserve area
	cmp x12, x27
	b.ge _GenGC_MinorC_heapend // check for no objects
_GenGC_MinorC_heaploop:				# $t0: index, $gp: limit
 	add x12, x12, #4 // skip over eyecatcher
	add x9, xzr, #-1 // check for eyecatcher
	ldr x10, [x12, #obj_eyecatch]
	cmp x9, x10
	b.ne _GenGC_MinorC_error // eyecatcher not found
	ldr x0, [x12, #obj_size] // get object size
	lsl x0, x0, #2 // words to bytes
	ldr x9, [x12, #obj_tag] // get the object's tag
	ldr x10, =_int_tag
	ldr x10, [x10] // test for int object
	cmp x9, x10
	b.eq _GenGC_MinorC_int
	ldr x10, =_bool_tag
	ldr x10, [x10] // test for bool object 
	cmp x9, x10
	b.eq _GenGC_MinorC_bool
	ldr x10, =_string_tag
	ldr x10, [x10] // test for string object
	cmp x9, x10
	b.eq _GenGC_MinorC_string
_GenGC_MinorC_other:
 	add x9, x12, #obj_attr // start at first attribute
	add x10, x12, x0 // limit of attributes
	cmp x9, x10
	b.ge _GenGC_MinorC_nextobj  //check for no attributes
	str x12, [sp, #16] // save pointer to object
	str x0, [sp, #12] // save object size
	str x10, [sp, #4] // save limit
_GenGC_MinorC_objloop:				# $t1: index, $t2: limit
 	str x9, [sp, #8] // save index
	ldr x9, [x9, #0] // set pointer to check
	bl _GenGC_ChkCopy // check and copy
	ldr x9, [sp, #8] // restore index
	str x0, [x9, #0] // update object pointer
	ldr x10, [sp, #4] // restore limit
	add x9, x9, #4
	cmp x9, x10
	b.lt _GenGC_MinorC_objloop // loop
_GenGC_MinorC_objend:
 	ldr x12, [sp, #16] // restore pointer to object
	ldr x0, [sp, #12] // restore object size
	b _GenGC_MinorC_nextobj // next object
_GenGC_MinorC_string:
 	str x12, [sp, #16] // save pointer to object
	str x0, [sp, #12] // save object size
	ldr x0, [x12, #str_size]
	bl _GenGC_ChkCopy // check and copy
	ldr x12, [sp, #16] // restore pointer to object
	str x0, [x12, #str_size] // update size pointer
	ldr x0, [sp, #12] // restore object size
_GenGC_MinorC_int:
_GenGC_MinorC_bool:
_GenGC_MinorC_nextobj:
 	add x12, x12, x0 // find next object
	cmp x12, x27 // loop
	b.lt _GenGC_MinorC_heaploop
	//add	$t0 $t0 $a0			# find next object
 	//blt	$t0 $gp _GenGC_MinorC_heaploop	# loop
_GenGC_MinorC_heapend:
 	adr x12, heap_start
	str x27, [x12, #GenGC_HDRL2] // set L2 to $gp
	ldr x0, [x12, #GenGC_HDRL1]
	sub x0, x27, x0 // find size after collection
	ldr x30, [sp, #20] // restore return address
	add sp, sp, #40
	ret // return
_GenGC_MinorC_error:
 	ldr x0, =_GenGC_MINORERROR // show error message
    bl puts
	mov x0, #1
	bl exit // exit(1)

 	.globl _GenGC_OfsCopy
_GenGC_OfsCopy:
    cmp x0, x1
	b.lt _GenGC_OfsCopy_done // check lower bound
	cmp x0, x7
	b.ge _GenGC_OfsCopy_done // check upper bound
 	and x10, x0, #1 // check if odd
	cmp x10, xzr
	b.ne _GenGC_OfsCopy_done
	add x10, xzr, #-1
	ldr x9, [x0, #obj_eyecatch] // check eyecatcher
	cmp x10, x9
	b.ne _gc_abort
	ldr x9, [x0, #obj_tag] // check object tag
	cmp x10, x9
	b.eq _GenGC_OfsCopy_done
	cmp x0, x2
	b.lt _GenGC_OfsCopy_old
	sub x6, x1, x2 // compute offset
	add x0, x0, x6 // apply pointer offset
	ret // return
_GenGC_OfsCopy_old:
	ldr x9, [x1, #obj_size] // get size of object
	lsl x9, x9, #2 // convert words to bytes
	cmp x9, xzr 
	b.eq _GenGC_OfsCopy_forward // if size = 0, get forwarding pointer
 	mov x12, x0 // save pointer to old object in $t0
	add x6, x27, x9 // test allocation
	add x6, x6, #4
	cmp x6, x26
	b.lt _GenGC_OfsCopy_memok
	sub x0, x6, x26 // amount to expand minus 1
	add x6, xzr, #1
	lsl x6, x6, #GenGC_HEAPEXPGRAN
	add x0, x0, x6
	add x6, x6, #-1
	mvn x6, x6 // get grain mask
	and x0, x0, x6 // align to grain size
	bl sbrk // expand heap
	mov x0, #0 // get end of heap in $v0
	bl sbrk
	mov x6, x0
	mov x26, x6 // save heap end in $s7
	mov x0, x12 // restore pointer to old object in $a0
_GenGC_OfsCopy_memok:
 	add x27, x27, #4 // allocate memory for eyecatcher
	mov x0, x27 // get address of new object
	str x10, [x0, #obj_eyecatch] // save eye catcher
	add x9, x12, x9 // set $t1 to limit of copy
	mov x10, x12 // set $t2 to old object
_GenGC_OfsCopy_loop:
 	ldr x6, [x12, #0] // copy
	str x6, [x27, #0]
	add x12, x12, #4 // update each index
	add x27, x27, #4
	cmp x12, x9
	b.ne _GenGC_OfsCopy_loop // check for limit of copy
	str xzr, [x10, #obj_size] // set size to 0
	sub x6, x1, x2 // compute offset
	add x0, x0, x6 // apply pointer offset
	str x0, [x12, #obj_disp] // save forwarding pointer
_GenGC_OfsCopy_done:
	ret // return
_GenGC_OfsCopy_forward:
	ldr x0, [x0, #obj_disp] // get forwarding pointer
 	ret // return

 	.globl _GenGC_MajorC
_GenGC_MajorC:
	add sp, sp, #-40
	str x30, [sp, #20] // save return address
	adr x12, heap_start
 	ldr x26, [x12, #GenGC_HDRL4] // limit pointer for collection
	ldr x27, [x12, #GenGC_HDRL2] // allocation pointer for collection
	ldr x1, [x12, #GenGC_HDRL0] // set inputs for OfsCopy
	ldr x2, [x12, #GenGC_HDRL1]
	ldr x7, [x12, #GenGC_HDRL2]
	str x0, [sp, #16] // save stack end
	ldr x12, [x12, #GenGC_HDRSTK] // set $t0 to stack start
	mov x9, x0 // set $t1 to stack end
	cmp x12, x9
	b.le _GenGC_MajorC_stackend // check for empty stack
_GenGC_MajorC_stackloop: 			# $t1 stack end, $t0 index
 	add x12, x12, #-4 // update index
	str x12, [sp, #12] // save stack index
	ldr x0, [x12, #4] // get stack item
	bl _GenGC_OfsCopy // check and copy
	ldr x12, [sp, #12] // load stack index
	str x0, [x12, #4]
	ldr x9, [sp, #16] // restore stack end
	cmp x12, x9
	b.gt _GenGC_MajorC_stackloop // loop
_GenGC_MajorC_stackend:
	adr x12, heap_start
	ldr x12, [x12, #GenGC_HDRREG] // get Register mask
	str x12, [sp, #16] // save Register mask
_GenGC_MajorC_reg16:
	lsr x12, x12, #16 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg17 // check if set
	mov x0, x19 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x19, x0 // update register
_GenGC_MajorC_reg17:
	ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #17 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg18 // check if set
	mov x0, x20 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x20, x0 // update register
_GenGC_MajorC_reg18:
 	ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #18 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg19 // check if set
	mov x0, x21 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x21, x0 // update register
_GenGC_MajorC_reg19:
 	ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #19 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg20 // check if set
	mov x0, x22 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x22, x0 // update register
_GenGC_MajorC_reg20:
	ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #20 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg21 // check if set
	mov x0, x23 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x23, x0 // update register
_GenGC_MajorC_reg21:
    ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #21 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg22 // check if set
	mov x0, x24 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x24, x0 // update register
_GenGC_MajorC_reg22:
	ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #22 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg24 // check if set
	mov x0, x25 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x25, x0 // update register
_GenGC_MajorC_reg24:
	ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #24 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg25 // check if set
	mov x0, x14 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x14, x0 // update register
_GenGC_MajorC_reg25:
    ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #25 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg30 // check if set
	mov x0, x15 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x15, x0 // update register
_GenGC_MajorC_reg30:
	ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #30 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_reg31 // check if set
	mov x0, x29 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x29, x0 // update register
_GenGC_MajorC_reg31:
	ldr x12, [sp, #16] // restore mask
	lsr x12, x12, #31 // shift to proper bit
    add x9, x12, #1
	cmp x9, xzr
	b.eq _GenGC_MajorC_regend // check if set
	mov x0, x30 // set test pointer
	bl _GenGC_OfsCopy // check and copy
	mov x30, x0 // update register
_GenGC_MajorC_regend:
	adr x12, heap_start
 	ldr x12, [x12, #GenGC_HDRL1] // start of X area
	cmp x12, x27
	b.ge _GenGC_MajorC_heapend // check for no objects
_GenGC_MajorC_heaploop:				# $t0: index, $gp: limit
 	add x12, x12, #4 // skip over eyecatcher
	add x9, xzr, #-1 // check for eyecatcher
	ldr x10, [x12, #obj_eyecatch]
	cmp x9, x10
	b.ne _GenGC_MajorC_error // eyecatcher not found
	ldr x0, [x12, #obj_size] // get object size
	lsl x0, x0, #2 // words to bytes
	ldr x9, [x12, #obj_tag] // get the object's tag
	ldr x10, =_int_tag // test for int object
	ldr x10, [x10]
	cmp x9, x10
	b.eq _GenGC_MajorC_int
	ldr x10, =_bool_tag // test for bool object
	ldr x10, [x10]
	cmp x9, x10
	b.eq _GenGC_MajorC_bool
	ldr x10, =_string_tag // test for string object
	ldr x10, [x10]
	cmp x9, x10
	b.eq _GenGC_MajorC_string
_GenGC_MajorC_other:
 	add x9, x12, #obj_attr // start at first attribute
	add x10, x12, x0 // limit of attributes
	cmp x9, x10
	b.ge _GenGC_MajorC_nextobj // check for no attributes
	str x12, [sp, #16] // save pointer to object
	str x0, [sp, #12] // save object size
	str x10, [sp, #4] // save limit
_GenGC_MajorC_objloop:				// $t1: index, $t2: limit
 	str x9, [sp, #8] // save index
	ldr x0, [x9, #0] // set pointer to check 
	bl _GenGC_OfsCopy // check and copy
	ldr x9, [sp, #8] // restore index
	str x0, [x9, #0] // update object pointer
	ldr x10, [sp, #4] // restore limit
	add x9, x9, #4
	cmp x9, x10
	b.lt _GenGC_MajorC_objloop // loop
_GenGC_MajorC_objend:
	ldr x12, [sp, #16] // restore pointer to object
	ldr x0, [sp, #12] // restore object size
	b _GenGC_MajorC_nextobj // next object
_GenGC_MajorC_string:
	str x12, [sp, #16] // save pointer to object
	str x0, [sp, #12] // save object size
	ldr x0, [x12, #str_size] // set test pointer
 	bl _GenGC_OfsCopy // check and copy
	ldr x12, [sp, #16] // restore pointer to object
	str x0, [x12, #str_size] // update size pointer
	ldr x0, [sp, #12] // restore object size
_GenGC_MajorC_int:
_GenGC_MajorC_bool:
_GenGC_MajorC_nextobj:
	add x12, x12, x0 // find next object
	cmp x12, x27
	b.lt _GenGC_MajorC_heaploop // loop
_GenGC_MajorC_heapend:
	adr x12, heap_start
 	ldr x0, [x12, #GenGC_HDRL2] // get end of collection
	sub x0, x27, x0 // get length after collection
	ldr x9, [x12, #GenGC_HDRL0] // get L0
	ldr x10, [x12, #GenGC_HDRL1] // get L1
	cmp x10, x27
	b.ge _GenGC_MajorC_bcpyend // test for empty copy
_GenGC_MajorC_bcpyloop:				# $t2 index, $gp limit, $t1 dest
 	ldr x6, [x10, #0] // copy
	str x6, [x9, #0] 
	add x10, x10, #4 // update each index
	add x9, x9, #4
	cmp x10, x27
	b.ne _GenGC_MajorC_bcpyloop // loop
_GenGC_MajorC_bcpyend:
 	str x26, [x12, #GenGC_HDRL4] // save end of heap
	ldr x9, [x12, #GenGC_HDRL0] // get L0
	ldr x10, [x12, #GenGC_HDRL1] // get L1
	sub x9, x10, x9 // find offset of block copy
	sub x27, x27, x9 // find end of old area
	str x27, [x12, #GenGC_HDRL1] // save end of old area
	ldr x30, [sp, #20] // restore return address
	add sp, sp, #40
	ret // return
_GenGC_MajorC_error:
	ldr x0, =_GenGC_MAJORERROR
	bl puts
 	mov x0, #1
	bl exit // exit(1)

// 	.globl	_GenGC_QRegMask
// _GenGC_QRegMask:
// 	la	$a0 heap_start			# set $a0 to the start of the heap
// 	lw	$a0 GenGC_HDRREG($a0)		# get the Register mask
// 	jr	$ra				# return

	.globl _NoGC_Init
_NoGC_Init:
	adr x27, heap_start // set $gp to the start of the heap
	mov x0, #0 // get heap end
    bl sbrk  // sbrk
	mov x26, x0 // set limit pointer
	ret

	.globl _NoGC_Collect
_NoGC_Collect:
	ldr x0, =_NoGC_COLLECT // show collection message
	bl puts

_NoGC_Collect_loop:
	add x12, x27, x1 // test allocation
	cmp x12, x26
	b.lt _NoGC_Collect_ok // stop if enough
	mov x0, #NoGC_EXPANDSIZE // set the size to expand the heap
	bl sbrk // expand heap
	mov x0, #0 // get heap end
	bl sbrk
	mov x6, x0
	mov x26, x6 // set limit pointer
	b _NoGC_Collect_loop // loop
_NoGC_Collect_ok:
	ret // return

